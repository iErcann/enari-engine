import * as Behaviour from '../behaviour';
import * as Initializer from '../initializer';
import { EULER, POOL_MAX } from '../constants';
import { INITIALIZER_TYPES_THAT_REQUIRE_THREE, SUPPORTED_JSON_BEHAVIOUR_TYPES, SUPPORTED_JSON_INITIALIZER_TYPES } from './constants';
import Rate from '../initializer/Rate';
/**
 * Makes a rate instance.
 *
 * @param {object} json - The data required to construct a Rate instance
 * @return {Rate}
 */

const makeRate = json => Rate.fromJSON(json);
/**
 * Makes initializers from json items.
 *
 * @param {array<object>} items - An array of objects which provide initializer constructor params
 * @param {object} THREE - The Web GL Api to use
 * @return {array<Initializer>}
 */


const makeInitializers = (items, THREE) => {
  const initializers = [];
  items.forEach(data => {
    const {
      type,
      properties
    } = data;

    if (!SUPPORTED_JSON_INITIALIZER_TYPES.includes(type)) {
      throw new Error(`The initializer type ${type} is invalid or not yet supported`);
    }

    if (INITIALIZER_TYPES_THAT_REQUIRE_THREE.includes(type)) {
      initializers.push(Initializer[type].fromJSON(properties, THREE));
    } else {
      initializers.push(Initializer[type].fromJSON(properties));
    }
  });
  return initializers;
};
/**
 * Makes behaviours from json items.
 *
 * @param {array<object>} items - An array of objects which provide behaviour constructor params
 * @return {array<Behaviour>}
 */


const makeBehaviours = items => {
  const behaviours = [];
  items.forEach(data => {
    const {
      type,
      properties
    } = data;

    if (!SUPPORTED_JSON_BEHAVIOUR_TYPES.includes(type)) {
      throw new Error(`The behaviour type ${type} is invalid or not yet supported`);
    }

    behaviours.push(Behaviour[type].fromJSON(properties));
  });
  return behaviours;
};
/**
 * Creates a System instance from a JSON object.
 *
 * @deprecated Use fromJSONAsync instead.
 *
 * @param {object} json - The JSON to create the System instance from
 * @param {object} THREE - The Web GL Api to use
 * @param {function} System - The system class
 * @param {function} Emitter - The emitter class
 * @param {number} json.preParticles - The predetermined number of particles
 * @param {string} json.integrationType - The integration algorithm to use
 * @param {array<object>} json.emitters - The emitters for the system instance
 * @return {System}
 */


export default ((json, THREE, System, Emitter) => {
  const {
    preParticles = POOL_MAX,
    integrationType = EULER,
    emitters = []
  } = json;
  const system = new System(THREE, preParticles, integrationType);
  emitters.forEach(data => {
    const emitter = new Emitter();
    const {
      rate,
      rotation,
      initializers,
      behaviours,
      emitterBehaviours = [],
      position,
      totalEmitTimes = Infinity,
      life = Infinity
    } = data;
    emitter.setRate(makeRate(rate)).setRotation(rotation).setInitializers(makeInitializers(initializers, THREE)).setBehaviours(makeBehaviours(behaviours)).setEmitterBehaviours(makeBehaviours(emitterBehaviours)).setPosition(position).emit(totalEmitTimes, life);
    system.addEmitter(emitter);
  });
  return system;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2Zyb21KU09OLmpzIl0sIm5hbWVzIjpbIkJlaGF2aW91ciIsIkluaXRpYWxpemVyIiwiRVVMRVIiLCJQT09MX01BWCIsIklOSVRJQUxJWkVSX1RZUEVTX1RIQVRfUkVRVUlSRV9USFJFRSIsIlNVUFBPUlRFRF9KU09OX0JFSEFWSU9VUl9UWVBFUyIsIlNVUFBPUlRFRF9KU09OX0lOSVRJQUxJWkVSX1RZUEVTIiwiUmF0ZSIsIm1ha2VSYXRlIiwianNvbiIsImZyb21KU09OIiwibWFrZUluaXRpYWxpemVycyIsIml0ZW1zIiwiVEhSRUUiLCJpbml0aWFsaXplcnMiLCJmb3JFYWNoIiwiZGF0YSIsInR5cGUiLCJwcm9wZXJ0aWVzIiwiaW5jbHVkZXMiLCJFcnJvciIsInB1c2giLCJtYWtlQmVoYXZpb3VycyIsImJlaGF2aW91cnMiLCJTeXN0ZW0iLCJFbWl0dGVyIiwicHJlUGFydGljbGVzIiwiaW50ZWdyYXRpb25UeXBlIiwiZW1pdHRlcnMiLCJzeXN0ZW0iLCJlbWl0dGVyIiwicmF0ZSIsInJvdGF0aW9uIiwiZW1pdHRlckJlaGF2aW91cnMiLCJwb3NpdGlvbiIsInRvdGFsRW1pdFRpbWVzIiwiSW5maW5pdHkiLCJsaWZlIiwic2V0UmF0ZSIsInNldFJvdGF0aW9uIiwic2V0SW5pdGlhbGl6ZXJzIiwic2V0QmVoYXZpb3VycyIsInNldEVtaXR0ZXJCZWhhdmlvdXJzIiwic2V0UG9zaXRpb24iLCJlbWl0IiwiYWRkRW1pdHRlciJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLQSxTQUFaLE1BQTJCLGNBQTNCO0FBQ0EsT0FBTyxLQUFLQyxXQUFaLE1BQTZCLGdCQUE3QjtBQUVBLFNBQVNDLEtBQVQsRUFBZ0JDLFFBQWhCLFFBQWdDLGNBQWhDO0FBQ0EsU0FDRUMsb0NBREYsRUFFRUMsOEJBRkYsRUFHRUMsZ0NBSEYsUUFJTyxhQUpQO0FBTUEsT0FBT0MsSUFBUCxNQUFpQixxQkFBakI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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Q3VCLElBQUQsQ0FEbkIsRUFFR1EsV0FGSCxDQUVlUCxRQUZmLEVBR0dRLGVBSEgsQ0FHbUI3QixnQkFBZ0IsQ0FBQ0csWUFBRCxFQUFlRCxLQUFmLENBSG5DLEVBSUc0QixhQUpILENBSWlCbkIsY0FBYyxDQUFDQyxVQUFELENBSi9CLEVBS0dtQixvQkFMSCxDQUt3QnBCLGNBQWMsQ0FBQ1csaUJBQUQsQ0FMdEMsRUFNR1UsV0FOSCxDQU1lVCxRQU5mLEVBT0dVLElBUEgsQ0FPUVQsY0FQUixFQU93QkUsSUFQeEI7QUFTQVIsSUFBQUEsTUFBTSxDQUFDZ0IsVUFBUCxDQUFrQmYsT0FBbEI7QUFDRCxHQXZCRDtBQXlCQSxTQUFPRCxNQUFQO0FBQ0QsQ0FsQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCZWhhdmlvdXIgZnJvbSAnLi4vYmVoYXZpb3VyJztcbmltcG9ydCAqIGFzIEluaXRpYWxpemVyIGZyb20gJy4uL2luaXRpYWxpemVyJztcblxuaW1wb3J0IHsgRVVMRVIsIFBPT0xfTUFYIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIElOSVRJQUxJWkVSX1RZUEVTX1RIQVRfUkVRVUlSRV9USFJFRSxcbiAgU1VQUE9SVEVEX0pTT05fQkVIQVZJT1VSX1RZUEVTLFxuICBTVVBQT1JURURfSlNPTl9JTklUSUFMSVpFUl9UWVBFUyxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5pbXBvcnQgUmF0ZSBmcm9tICcuLi9pbml0aWFsaXplci9SYXRlJztcblxuLyoqXG4gKiBNYWtlcyBhIHJhdGUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUgZGF0YSByZXF1aXJlZCB0byBjb25zdHJ1Y3QgYSBSYXRlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtSYXRlfVxuICovXG5jb25zdCBtYWtlUmF0ZSA9IGpzb24gPT4gUmF0ZS5mcm9tSlNPTihqc29uKTtcblxuLyoqXG4gKiBNYWtlcyBpbml0aWFsaXplcnMgZnJvbSBqc29uIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gaXRlbXMgLSBBbiBhcnJheSBvZiBvYmplY3RzIHdoaWNoIHByb3ZpZGUgaW5pdGlhbGl6ZXIgY29uc3RydWN0b3IgcGFyYW1zXG4gKiBAcGFyYW0ge29iamVjdH0gVEhSRUUgLSBUaGUgV2ViIEdMIEFwaSB0byB1c2VcbiAqIEByZXR1cm4ge2FycmF5PEluaXRpYWxpemVyPn1cbiAqL1xuY29uc3QgbWFrZUluaXRpYWxpemVycyA9IChpdGVtcywgVEhSRUUpID0+IHtcbiAgY29uc3QgaW5pdGlhbGl6ZXJzID0gW107XG5cbiAgaXRlbXMuZm9yRWFjaChkYXRhID0+IHtcbiAgICBjb25zdCB7IHR5cGUsIHByb3BlcnRpZXMgfSA9IGRhdGE7XG5cbiAgICBpZiAoIVNVUFBPUlRFRF9KU09OX0lOSVRJQUxJWkVSX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgaW5pdGlhbGl6ZXIgdHlwZSAke3R5cGV9IGlzIGludmFsaWQgb3Igbm90IHlldCBzdXBwb3J0ZWRgXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChJTklUSUFMSVpFUl9UWVBFU19USEFUX1JFUVVJUkVfVEhSRUUuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIGluaXRpYWxpemVycy5wdXNoKEluaXRpYWxpemVyW3R5cGVdLmZyb21KU09OKHByb3BlcnRpZXMsIFRIUkVFKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxpemVycy5wdXNoKEluaXRpYWxpemVyW3R5cGVdLmZyb21KU09OKHByb3BlcnRpZXMpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpbml0aWFsaXplcnM7XG59O1xuXG4vKipcbiAqIE1ha2VzIGJlaGF2aW91cnMgZnJvbSBqc29uIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gaXRlbXMgLSBBbiBhcnJheSBvZiBvYmplY3RzIHdoaWNoIHByb3ZpZGUgYmVoYXZpb3VyIGNvbnN0cnVjdG9yIHBhcmFtc1xuICogQHJldHVybiB7YXJyYXk8QmVoYXZpb3VyPn1cbiAqL1xuY29uc3QgbWFrZUJlaGF2aW91cnMgPSBpdGVtcyA9PiB7XG4gIGNvbnN0IGJlaGF2aW91cnMgPSBbXTtcblxuICBpdGVtcy5mb3JFYWNoKGRhdGEgPT4ge1xuICAgIGNvbnN0IHsgdHlwZSwgcHJvcGVydGllcyB9ID0gZGF0YTtcblxuICAgIGlmICghU1VQUE9SVEVEX0pTT05fQkVIQVZJT1VSX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgYmVoYXZpb3VyIHR5cGUgJHt0eXBlfSBpcyBpbnZhbGlkIG9yIG5vdCB5ZXQgc3VwcG9ydGVkYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBiZWhhdmlvdXJzLnB1c2goQmVoYXZpb3VyW3R5cGVdLmZyb21KU09OKHByb3BlcnRpZXMpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJlaGF2aW91cnM7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTeXN0ZW0gaW5zdGFuY2UgZnJvbSBhIEpTT04gb2JqZWN0LlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBmcm9tSlNPTkFzeW5jIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUgSlNPTiB0byBjcmVhdGUgdGhlIFN5c3RlbSBpbnN0YW5jZSBmcm9tXG4gKiBAcGFyYW0ge29iamVjdH0gVEhSRUUgLSBUaGUgV2ViIEdMIEFwaSB0byB1c2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFN5c3RlbSAtIFRoZSBzeXN0ZW0gY2xhc3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEVtaXR0ZXIgLSBUaGUgZW1pdHRlciBjbGFzc1xuICogQHBhcmFtIHtudW1iZXJ9IGpzb24ucHJlUGFydGljbGVzIC0gVGhlIHByZWRldGVybWluZWQgbnVtYmVyIG9mIHBhcnRpY2xlc1xuICogQHBhcmFtIHtzdHJpbmd9IGpzb24uaW50ZWdyYXRpb25UeXBlIC0gVGhlIGludGVncmF0aW9uIGFsZ29yaXRobSB0byB1c2VcbiAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0ganNvbi5lbWl0dGVycyAtIFRoZSBlbWl0dGVycyBmb3IgdGhlIHN5c3RlbSBpbnN0YW5jZVxuICogQHJldHVybiB7U3lzdGVtfVxuICovXG5leHBvcnQgZGVmYXVsdCAoanNvbiwgVEhSRUUsIFN5c3RlbSwgRW1pdHRlcikgPT4ge1xuICBjb25zdCB7XG4gICAgcHJlUGFydGljbGVzID0gUE9PTF9NQVgsXG4gICAgaW50ZWdyYXRpb25UeXBlID0gRVVMRVIsXG4gICAgZW1pdHRlcnMgPSBbXSxcbiAgfSA9IGpzb247XG4gIGNvbnN0IHN5c3RlbSA9IG5ldyBTeXN0ZW0oVEhSRUUsIHByZVBhcnRpY2xlcywgaW50ZWdyYXRpb25UeXBlKTtcblxuICBlbWl0dGVycy5mb3JFYWNoKGRhdGEgPT4ge1xuICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJhdGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIGluaXRpYWxpemVycyxcbiAgICAgIGJlaGF2aW91cnMsXG4gICAgICBlbWl0dGVyQmVoYXZpb3VycyA9IFtdLFxuICAgICAgcG9zaXRpb24sXG4gICAgICB0b3RhbEVtaXRUaW1lcyA9IEluZmluaXR5LFxuICAgICAgbGlmZSA9IEluZmluaXR5LFxuICAgIH0gPSBkYXRhO1xuXG4gICAgZW1pdHRlclxuICAgICAgLnNldFJhdGUobWFrZVJhdGUocmF0ZSkpXG4gICAgICAuc2V0Um90YXRpb24ocm90YXRpb24pXG4gICAgICAuc2V0SW5pdGlhbGl6ZXJzKG1ha2VJbml0aWFsaXplcnMoaW5pdGlhbGl6ZXJzLCBUSFJFRSkpXG4gICAgICAuc2V0QmVoYXZpb3VycyhtYWtlQmVoYXZpb3VycyhiZWhhdmlvdXJzKSlcbiAgICAgIC5zZXRFbWl0dGVyQmVoYXZpb3VycyhtYWtlQmVoYXZpb3VycyhlbWl0dGVyQmVoYXZpb3VycykpXG4gICAgICAuc2V0UG9zaXRpb24ocG9zaXRpb24pXG4gICAgICAuZW1pdCh0b3RhbEVtaXRUaW1lcywgbGlmZSk7XG5cbiAgICBzeXN0ZW0uYWRkRW1pdHRlcihlbWl0dGVyKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHN5c3RlbTtcbn07XG4iXX0=